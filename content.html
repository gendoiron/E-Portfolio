<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Content &amp; Deliverables – Geneviève Doiron</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Geneviève Doiron</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./resume.html"> 
<span class="menu-text">Resume</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./publications.html"> 
<span class="menu-text">Photography</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./writing.html"> 
<span class="menu-text">Writing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./content.html" aria-current="page"> 
<span class="menu-text">Projects</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#save-cable-bay" id="toc-save-cable-bay" class="nav-link active" data-scroll-target="#save-cable-bay">Save Cable Bay</a>
  <ul class="collapse">
  <li><a href="#study-site-map" id="toc-study-site-map" class="nav-link" data-scroll-target="#study-site-map">Study Site Map</a></li>
  <li><a href="#client-work" id="toc-client-work" class="nav-link" data-scroll-target="#client-work">Client Work:</a></li>
  <li><a href="#development-maps" id="toc-development-maps" class="nav-link" data-scroll-target="#development-maps">Development Maps</a>
  <ul class="collapse">
  <li><a href="#proposed-developments" id="toc-proposed-developments" class="nav-link" data-scroll-target="#proposed-developments">Proposed Developments</a></li>
  <li><a href="#alternative-developments" id="toc-alternative-developments" class="nav-link" data-scroll-target="#alternative-developments">Alternative Developments</a></li>
  </ul></li>
  <li><a href="#capstone-research" id="toc-capstone-research" class="nav-link" data-scroll-target="#capstone-research">Capstone Research:</a></li>
  </ul></li>
  <li><a href="#individual-tree-segmentation" id="toc-individual-tree-segmentation" class="nav-link" data-scroll-target="#individual-tree-segmentation">Individual Tree Segmentation</a>
  <ul class="collapse">
  <li><a href="#skills-tools-used" id="toc-skills-tools-used" class="nav-link" data-scroll-target="#skills-tools-used">Skills &amp; Tools Used:</a></li>
  <li><a href="#code-snippets" id="toc-code-snippets" class="nav-link" data-scroll-target="#code-snippets">Code Snippets</a></li>
  <li><a href="#applications" id="toc-applications" class="nav-link" data-scroll-target="#applications">Applications</a></li>
  </ul></li>
  <li><a href="#least-cost-path-analysis" id="toc-least-cost-path-analysis" class="nav-link" data-scroll-target="#least-cost-path-analysis">Least Cost Path Analysis</a>
  <ul class="collapse">
  <li><a href="#skills-tools-used-1" id="toc-skills-tools-used-1" class="nav-link" data-scroll-target="#skills-tools-used-1"><strong>Skills &amp; Tools Used:</strong></a></li>
  <li><a href="#applications-1" id="toc-applications-1" class="nav-link" data-scroll-target="#applications-1">Applications:</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Content &amp; Deliverables</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="save-cable-bay" class="level1">
<h1>Save Cable Bay</h1>
<p>The Cable Bay Trail Area is the location of both a volunteer project I support and my capstone research for my master’s degree. Located on Southeastern Vancouver Island, Cable Bay is surrounded by 400 acres of undeveloped land within the northern range of Garry oak ecosystems (GOEs). The area faces proposed developments currently being opposed by the Save Cable Bay community group.</p>
<section id="study-site-map" class="level3">
<h3 class="anchored" data-anchor-id="study-site-map">Study Site Map</h3>
<p><img src="images/clipboard-1464195342.png" class="img-fluid"></p>
</section>
<section id="client-work" class="level2">
<h2 class="anchored" data-anchor-id="client-work">Client Work:</h2>
<p>As a volunteer for the Save Cable Bay community group, I offer geospatial analysis and visualization support, helping them create materials that support their conservation efforts. This client-based work allows me to collaborate closely with the group, where we exchange ideas and refine materials based on their input, ensuring that the final products effectively communicate their message. The work involves handling a variety of data types, including participatory mapping, which enriches the project by incorporating local knowledge from community members.</p>
<p>Additionally, I am responsible for data sourcing and management, creating and maintaining a comprehensive inventory to track project data for a large group of volunteers. This experience is invaluable for my career, as it strengthens my skills in client communication, data management, and geospatial analysis, while also providing me with practical experience in a real-world, community-based conservation setting.</p>
<p>The maps I created for the community conservation group visually represent both the proposed developments in the area and their alternative vision for the land. These maps serve as critical tools for the group to communicate the potential impacts of development versus their conservation goals. By highlighting the areas of concern, I have helped the group demonstrate how proposed projects could affect the environment, and how their alternative vision aligns better with the community’s conservation values. These maps not only support the group’s advocacy efforts but also provide a clear, visual way to engage with the public, decision-makers, and stakeholders in discussions about land use and conservation priorities. This experience has been an excellent opportunity to enhance my skills in spatial analysis and map design, which are essential for effective communication in environmental management and conservation planning.</p>
</section>
<section id="development-maps" class="level2">
<h2 class="anchored" data-anchor-id="development-maps">Development Maps</h2>
<section id="proposed-developments" class="level3">
<h3 class="anchored" data-anchor-id="proposed-developments">Proposed Developments</h3>
<p>There is proposed development on both sides of the trail, with the parcels on the East to face potential residential expansion by Cable Bay Estates (CBE) and to the West to be rezoned for heavy industrial use by Nanaimo Forest Products (NFP). Bordering these parcels to the West is industrially zoned land that hosts the Harmac Pulp Mill which is also owned by NFP. The expansion of their property is proposed to include a subdivided industrial park (Seward Developments Inc., 2022). Nanaimo Forest Products has agreed to include a 100m buffer from the trail, however the proposed buffer is only an average of 100m with 50% of the boundary at only 50m from the trail (Seward Developments Inc., 2022). The eastern parcels are facing proposed residential development by CBE; the private owner has applied for subdivision into 34 residential sites (Williamson &amp; Associates Professional Surveyors, 2023).</p>
<p><img src="images/clipboard-1755856040.jpeg" class="img-fluid"></p>
</section>
<section id="alternative-developments" class="level3">
<h3 class="anchored" data-anchor-id="alternative-developments">Alternative Developments</h3>
<p><img src="images/clipboard-2196079768.jpeg" class="img-fluid"></p>
</section>
</section>
<section id="capstone-research" class="level2">
<h2 class="anchored" data-anchor-id="capstone-research">Capstone Research:</h2>
<p>On top of the volunteer work, I am conducting my capstone research in the Cable Bay area. In my ongoing capstone research, I am exploring how combining Light Detection and Ranging (LiDAR) data with optical imagery can improve species-level forest classification — witha particular emphasis on identifying rare species—a current limitation of existing approaches. Imagery only often struggle to accurately classify less common species due limited spatial resolution and similarities in spectral signatures. By integrating LiDAR’s detailed structural data with the spectral information from optical imagery, the study seeks to determine if this combination enhances the accuracy of identifying Garry Oaks compared to using optical imagery alone. Specifically, this research aims to support the efforts of the Save Cable Bay community group in protecting Garry Oak ecosystems, which are relatively rare in the research area. Once the most accurate model is determined, a subsequent analysis will be conducted on the impacts of the proposed development scenarios on the Garry oak populations.</p>
<p>While the primary focus is on supporting Garry Oak conservation, the findings have broader applications in resource management and conservation, offering improved methods for species identification and ecosystem monitoring.</p>
</section>
</section>
<section id="individual-tree-segmentation" class="level1">
<h1>Individual Tree Segmentation</h1>
<p>This project demonstrates individual tree segmentation (ITS) and subsequent visualizatoin using LiDAR data. I highlight both canopy height model-based and point cloud-based methods for tree detection and segmentation. Specifically, the code snippets show the application of two algorthims: <strong><code>li2012</code></strong> and <strong><code>dalponte2016</code></strong>.</p>
<section id="skills-tools-used" class="level2">
<h2 class="anchored" data-anchor-id="skills-tools-used">Skills &amp; Tools Used:</h2>
<ul>
<li><p><strong>R Programming:</strong> Utilized R for data manipulation, analysis, and visualization.</p></li>
<li><p><strong>LiDAR Processing:</strong> Used the <strong><code>lidR</code></strong> package to load, filter, and normalize LiDAR data, removing outliers and correcting for ground elevation.</p></li>
<li><p><strong>Tree Segmentation:</strong> Applied the <strong><code>li2012</code></strong> algorithm on the point cloud data for tree segmentation and used the <strong><code>dalponte2016</code></strong> algorithm on CHM data to detect tree tops and segment individual trees.</p></li>
<li><p><strong>Visualization:</strong> Created 3D visualizations of segmented trees using the <strong><code>rgl</code></strong> package and compared results from both methods.</p></li>
<li><p><strong>Raster Analysis:</strong> Generated Canopy Height Models (CHM) at 0.5m resolution using <strong><code>terra</code></strong> to improve segmentation accuracy.</p></li>
</ul>
</section>
<section id="code-snippets" class="level2">
<h2 class="anchored" data-anchor-id="code-snippets">Code Snippets</h2>
<p>For both approaches I extracted a plot and subsequently pre-processed the data to remove noise and normalize the point cloud.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset" data-group="language">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true">Point Cloud Approach: Li 2012</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false">Canopy Height Model Approach: Dalponte 2016</a></li></ul>
<div class="tab-content" data-group="language">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<pre class="(.r)"><code># Read in plots    
plots &lt;- list.files(path = "Plots", pattern = "\\.las$", full.names = TRUE)

# For Loop to loop through the plots and segment
for(i in plots){
  output_dir &lt;- "li_trees"
  las &lt;- readLAS(i)
  li_trees &lt;- segment_trees(las, li2012(dt1 = 1.5, dt2 = 2, Zu = 15, hmin = 2, speed_up = 10))
  plot(li_trees, color = "treeID", pal = (pastel.colors(200)))
  output_file &lt;- file.path(output_dir, paste0("segmented_", basename(i)))
  writeLAS(li_trees, output_file)
}</code></pre>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<pre class="(.python)"><code># Create a canopy height model
CHM_1 &lt;- rasterize_canopy(MKRF_Plot_1, res = 0.5, pitfree(c(0,10,20,30), subcircle = 0.2, max_edge = (c(0,1))))

# Locate Tree Tops (local maximums)
ttops_1 &lt;-  locate_trees(CHM_1, lmf(ws=5, hmin=2))

# Segment using Dalponte 2016
plot1_seg_dal &lt;- segment_trees(MKRF_Plot_1, dalponte2016(CHM_1, ttops_1))</code></pre>
<p>(Optionally could smooth the CHM prior to tree detection)</p>
</div>
</div>
</div>
</section>
<section id="applications" class="level2">
<h2 class="anchored" data-anchor-id="applications">Applications</h2>
<p>Automatic individual tree segmentation is an evolving area of research with significant potential in forest management and ecological studies. While it can provide valuable insights into tree attributes such as height, crown diameter, and canopy structure, its accuracy is still limited, particularly in dense and complex forest environments. Despite these challenges, this technique offers promising applications in biodiversity monitoring, carbon stock estimation, forest health assessments, and precision forestry, where understanding individual tree characteristics is crucial for sustainable management and conservation efforts.</p>
</section>
</section>
<section id="least-cost-path-analysis" class="level1">
<h1>Least Cost Path Analysis</h1>
<p>I conducted a Least Cost Path (LCP) analysis to model Grizzly Bear movement across the Yellowhead region, considering various environmental and human factors that influence movement. The goal was to identify the most efficient route between two points by assessing the costs associated with different landscape features. LCP analysis factored in resistance elements such as terrain, land cover, and infrastructure.</p>
<section id="skills-tools-used-1" class="level2">
<h2 class="anchored" data-anchor-id="skills-tools-used-1"><strong>Skills &amp; Tools Used:</strong></h2>
<ul>
<li><p><strong>QGIS:</strong> Raster analysis including deriving input features, completing feature proximity analysis, and reclassifying based on weights of relative cost.</p>
<ul>
<li>Tools: “<strong>Slope</strong>,” “<strong>Reclassify,</strong>” and “<strong>Raster Calculator</strong>” <strong>“Proximity Analysis”</strong></li>
</ul></li>
<li><p><strong>ArcGIS:</strong> Final least cost analysis using the derived cost raster layers as inputs, and final visualization of results.</p>
<ul>
<li>Tools: “<strong>Distance Accumulation</strong>” and “<strong>Optimal Path as Line</strong>”</li>
</ul></li>
<li><p><strong>Results Visualization:</strong></p>
<ul>
<li>Creating the map to communicate the analysis, with its numerous input components, allowed me to strengthen my visual communication skills by effectively presenting complex data in a clear and accessible way, ensuring that key findings were easily understood.</li>
</ul></li>
</ul>
<p><img src="images/GEM510_Lab5_GD conv 1.png" class="img-fluid"></p>
</section>
<section id="applications-1" class="level2">
<h2 class="anchored" data-anchor-id="applications-1">Applications:</h2>
<p>The Least Cost Path (LCP) analysis is particularly valuable in conservation work and regional planning, where understanding landscape connectivity is crucial for maintaining habitat corridors and supporting species movement. It can be applied in projects aimed at mitigating habitat fragmentation, guiding conservation strategies, or planning for sustainable land use. Through this project, I also honed my ability to effectively communicate complex results through visual mapping, a skill essential for presenting findings to stakeholders and informing decision-making processes in local and regional environmental management.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>